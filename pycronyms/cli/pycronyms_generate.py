import os
import logging
import shutil
import sys

from typing import NoReturn, Dict, Tuple
from argparse import ArgumentParser, _SubParsersAction
from pathlib import Path

from pycronyms.pycronyms import Pycronyms
from pycronyms.providers import Wikipedia
from pycronyms.providers import Custom
from pycronyms._common import sorted_recursive
from pycronyms.acronyms import Acronyms
from pycronyms.handlers import HandlerJSON
from pycronyms.handler_acronyms import HandlerAcronyms
from pycronyms.statistics import Statistics

logger = logging.getLogger(__file__)

OUTPUT_DIRNAME = Path("pycronyms_output")

SUMMARY_MARKDOWN = """# Acronyms generation summary

This markdown file expose metrics produced by the acronyms generation using the `pycronyms` Python CLI. The language is represented by its code ISO 639-1.

@graph_section@

@matrix_section@
"""

GRAPH_MARKDOWN = """
## Graphs

Below are graphs showing the evolution of the number of acronyms over time.

![acronyms_graph](@acronyms_graph_filepath@)
"""

MATRIX_MARKDOWN = """
## Matrix

The matrix below shows the number of acronyms generated by language and category.
@matrix@
"""

EXT_HANDLERS_ACRONYMS: Dict[str, type[HandlerAcronyms]] = {
    "json": HandlerJSON,
}


def create_graph_section(acronyms_graph_filepath: Path) -> str:
    """_summary_

    Args:
        acronyms_graph_filepath (Path): _description_

    Returns:
        str: _description_
    """
    section = GRAPH_MARKDOWN.replace(
        "@acronyms_graph_filepath@", str(acronyms_graph_filepath)
    )

    return section


def create_matrix_section(matrix: str, is_empty: bool) -> str:
    """Returns the post-processed matrix markdown section.

    Args:
        matrix (str): The matrix. It should be an error message is `is_empty` is true. Otherwise it should be the markdown table.

        is_empty (bool): True means there are no acronyms.

    Returns:
        str: The matrix section.
    """

    if is_empty is True:
        return matrix

    section = MATRIX_MARKDOWN.replace("@matrix@", matrix)

    return section


def create_subparser_generate(
    subparsers: "_SubParsersAction[ArgumentParser]",
) -> ArgumentParser:
    """Creating a subparser for the generate subcommand.

    Returns:
        ArgumentParser: The created parser.
    """

    parser = subparsers.add_parser(
        "generate", help="Generate and write acronyms into a JSON file."
    )

    parser.add_argument(
        "-d",
        "--dir",
        required=False,
        default=OUTPUT_DIRNAME,
        type=Path,
    )

    return parser


def create_matrix_markdown(statistics: Statistics) -> Tuple[str, bool]:
    """This function returns the pycronyms generation summary in a matrix
    for the markdown language. It is a markdown table.

    Args:
        statistics (Statistics): The acronyms statistics.

    Returns:
        str: The matrix in a markdown table format.
    """

    if statistics.total == 0:
        return "Zero acronyms have been generated.", True

    # Creating each row of the matrix
    #
    # On the first row, there is the language names
    first_row = [
        "Category\\Language",
        *[l.iso_639_1_code for l in statistics.language],
        "Total",
    ]

    rows = []
    for category, cv in statistics.category.items():
        # Category name on the first column
        row = [category.value]

        # Language and category metrics
        for language in statistics.language:
            value = statistics.language_and_category[language][category]

            row.append(str(value))

        # Category total
        row.append(str(cv))
        # Adding the row with the others
        rows.append(row)

    lv = statistics.language.values()
    # On the last row, we must have the language total metrics
    last_row = ["Total", *[str(v) for v in lv], str(statistics.total)]
    rows.append(last_row)

    rows_str = []
    rows_str.append("| " + " | ".join(first_row) + " |")

    column_amount = len(lv) + 2
    rows_str.append("| - " * column_amount + "|")

    for row in rows:
        rows_str.append("| " + " | ".join(row) + " |")

    matrix_markdown = "\n".join(rows_str)

    return matrix_markdown, False


def create_summary_markdown(
    statistics: Statistics, acronyms_graph_filepath: Path
) -> str:
    """Returns the post-processed summary markdown content.

    Args:
        statistics (Statistics): The acronyms statistics.
        acronyms_graph_filepath (Path): The graph file path.

    Returns:
        str: The summary section.
    """

    matrix, is_empty = create_matrix_markdown(statistics)
    matrix_section = create_matrix_section(matrix, is_empty)
    graph_section = create_graph_section(acronyms_graph_filepath)

    summary = SUMMARY_MARKDOWN.replace("@matrix_section@", matrix_section).replace(
        "@graph_section@", graph_section
    )

    return summary


def write_acronyms(acronyms: Acronyms, dir: Path) -> NoReturn:
    """Write acronyms into data files.

    Args:
        acronyms (Acronyms): The acronyms.
        dir (Path): The base directory path.
    """

    basepath = dir / "all"

    for ext, handler_acronyms_class in EXT_HANDLERS_ACRONYMS.items():
        filepath = Path(f"{basepath}.{ext}")

        handler_acronyms_class.write(filepath, acronyms)

        logger.info(f"Successfully written acronyms to {filepath.absolute()}")


def write_markdown_summary(
    statistics: Statistics, filepath: Path, acronyms_graph_filepath: Path
) -> NoReturn:
    """Write the markdown summary to a README file.

    Args:
        statistics (Statistics): The acronyms statistics.
        filepath (Path): The file path.
        acronyms_graph_filepath (Path): The graph file path.
    """

    summary = create_summary_markdown(statistics, acronyms_graph_filepath)

    with open(filepath, "w+") as f:
        f.write(summary)

    logger.info(f"Successfully written the markdown summary to {filepath.absolute()}")


def write_statistics(statistics: Statistics, acronyms_graph_filepath: Path) -> NoReturn:
    """It updates, creates if needed, a CSV file to track acronyms statistics by date.
    It also create a plot PNG file.

    Args:
        statistics (Statistics): The acronyms statistics.
        acronyms_graph_filepath (Path): The graph file path.
    """

    statistics.append_to_csv()
    logger.info(
        f"Successfully wrote the CSV data to {statistics.filepath_csv.absolute()}"
    )

    statistics.create_plot(acronyms_graph_filepath)
    logger.info(f"Successfully wrote the chart to {acronyms_graph_filepath.absolute()}")


def generate(dir: Path) -> NoReturn:
    """Fetched every acronyms with every available providers. Once it has been fetched,
    the objects representing them are going to be written in JSON files.

    Args:
        dir (Path): The output directory path.
    """

    logging.basicConfig(format="%(asctime)s - %(levelname)s - %(message)s")
    a_logger = logging.getLogger("pycronyms.aggregator")
    a_logger.disabled = False
    a_logger.setLevel(logging.DEBUG)

    logger.setLevel(logging.DEBUG)

    pycronms = Pycronyms()
    pycronms.add_provider(Custom())
    pycronms.add_provider(Wikipedia())

    pycronms.fetch_all()
    logger.info(f"Fetched {pycronms.amount} acronyms.")

    os.makedirs(dir, exist_ok=True)
    logger.info(f"Created the directory {dir.absolute()} if needed")

    acronyms = sorted_recursive(pycronms.acronyms)

    statistics = pycronms.statistics
    statistics.filepath_csv = dir / "statistics.csv"
    acronyms_graph_filepath = dir / "acronyms_graph.png"

    try:
        write_acronyms(acronyms, dir)
        write_statistics(statistics, acronyms_graph_filepath)
        write_markdown_summary(
            statistics, dir / "README.md", "/" / acronyms_graph_filepath
        )
    except Exception as e:
        logger.exception(e)

        shutil.rmtree(dir, ignore_errors=True)
        logger.info(f"Removed the folder {dir.absolute()}")

        sys.exit(1)
