import os
import orjson
import logging
import shutil
import sys

from typing import NoReturn, Any, Dict, Tuple
from argparse import ArgumentParser, _SubParsersAction
from pathlib import Path
from collections import defaultdict

from pycronyms.pycronyms import Pycronyms
from pycronyms.providers import Wikipedia
from pycronyms.providers import Custom
from pycronyms._common import create_recursive_dict, sorted_recursive
from pycronyms.acronyms import AcronymsDict, Acronyms
from pycronyms.handlers import HandlerJSON
from pycronyms.handler_acronyms import HandlerAcronyms

logger = logging.getLogger(__file__)

OUTPUT_DIRNAME = Path("pycronyms_output")

SUMMARY_MARKDOWN = """# Acronyms generation summary

This markdown file expose metrics produced by the acronyms generation using the `pycronyms` Python CLI. The language is represented by its code ISO 639-1.

@matrix_section@
"""

MATRIX_MARKDOWN = """
## Matrix

The matrix below shows the number of acronyms generated by language and category.
@matrix@
"""

EXT_HANDLERS_ACRONYMS: Dict[str, type[HandlerAcronyms]] = {
    "json": HandlerJSON,
}


def create_matrix_section(matrix: str, is_empty: bool) -> str:
    """Returns the post-processed matrix markdown section.

    Args:
        matrix (str): The matrix. It should be an error message is `is_empty` is true. Otherwise it should be the markdown table.

        is_empty (bool): True means there are no acronyms.

    Returns:
        str: The matrix section.
    """

    if is_empty is True:
        return matrix

    section = MATRIX_MARKDOWN.replace("@matrix@", matrix)

    return section


def create_subparser_generate(
    subparsers: "_SubParsersAction[ArgumentParser]",
) -> ArgumentParser:
    """Creating a subparser for the generate subcommand.

    Returns:
        ArgumentParser: The created parser.
    """

    parser = subparsers.add_parser(
        "generate", help="Generate and write acronyms into a JSON file."
    )

    parser.add_argument(
        "-d",
        "--dir",
        required=False,
        default=OUTPUT_DIRNAME,
        type=Path,
    )

    return parser


def create_matrix_markdown(acronyms: Acronyms) -> Tuple[str, bool]:
    """This function returns the pycronyms generation summary in a matrix
    for the markdown language. It is a markdown table.

    Args:
        acronyms (Acronyms): Every acronyms represented as a dict.

    Returns:
        str: The matrix in a markdown table format.
    """

    matrix_metrics = create_recursive_dict(int, depth=2)

    # These dictionnaries contains total metrics and total languages.
    # They are useful to maintain a row order in the matrix.
    #
    # Each row value will be in the right column.
    category_metrics: Dict[str, int] = defaultdict(int)
    language_metrics: Dict[str, int] = defaultdict(int)

    acronyms_total = 0
    # Preprocessing to keep the same order on every row
    for language, lv in acronyms.items():
        for category, cv in lv.items():
            amount = len(cv)

            for acronym in cv.values():
                amount += len(acronym.extras)

            if amount == 0:
                continue

            matrix_metrics[language.iso_639_1_code][category.value] += amount
            language_metrics[language.iso_639_1_code] += amount
            category_metrics[category.value] += amount

            acronyms_total += amount

    lv = language_metrics.values()

    if acronyms_total == 0:
        return "Zero acronyms have been generated.", True

    # Creating each row of the matrix
    #
    # On the first row, there is the language names
    first_row = ["Category\\Language", *list(language_metrics), "Total"]

    rows = []
    for ck, cv in category_metrics.items():
        # Category name on the first column
        row = [ck]

        # Language and category metrics
        for lk in language_metrics:
            value = matrix_metrics[lk][ck]

            row.append(str(value))

        # Category total
        row.append(str(cv))
        # Adding the row with the others
        rows.append(row)

    # On the last row, we must have the language total metrics
    last_row = ["Total"] + [str(v) for v in lv] + [str(acronyms_total)]
    rows.append(last_row)

    rows_str = []
    rows_str.append("| " + " | ".join(first_row) + " |")

    column_amount = len(lv) + 2
    rows_str.append("| - " * column_amount + "|")

    for row in rows:
        rows_str.append("| " + " | ".join(row) + " |")

    matrix_markdown = "\n".join(rows_str)

    return matrix_markdown, False


def create_summary_markdown(acronyms: Acronyms) -> str:
    """Returns the post-processed summary markdown content.

    Args:
        acronyms (Acronyms): The acronyms.

    Returns:
        str: The summary section.
    """

    matrix, is_empty = create_matrix_markdown(acronyms)
    matrix_section = create_matrix_section(matrix, is_empty)

    summary = SUMMARY_MARKDOWN.replace("@matrix_section@", matrix_section)

    return summary


def write_acronyms(acronyms: Acronyms, dir: Path) -> NoReturn:
    """Write acronyms into data files

    Args:
        acronyms (Acronyms): The acronyms.
        dir (Path): The base directory path.
    """

    basepath = dir / "all"

    for ext, handler_acronyms_class in EXT_HANDLERS_ACRONYMS.items():
        filepath = Path(f"{basepath}.{ext}")

        handler_acronyms = handler_acronyms_class(filepath, acronyms)
        handler_acronyms.write()

        logger.info(f"Successfully written acronyms to {filepath.absolute()}")


def write_markdown_summary(acronyms_dict: AcronymsDict, dir: Path) -> NoReturn:
    """Write the markdown summary to a README file.

    Args:
        acronyms_dict (AcronymsDict): Every acronyms represented as a dict.
        dir (Path): The base directory path.
    """

    summary = create_summary_markdown(acronyms_dict)

    readme_path = dir / "README.md"
    with open(readme_path, "w+") as f:
        f.write(summary)

    logger.info(
        f"Successfully written the markdown summary to {readme_path.absolute()}"
    )


def generate(dir: Path) -> NoReturn:
    """Fetched every acronyms with every available providers. Once it has been fetched,
    the objects representing them are going to be written in JSON files.

    Args:
        dir (Path): The output directory path.
    """

    logging.basicConfig(format="%(asctime)s - %(levelname)s - %(message)s")
    a_logger = logging.getLogger("pycronyms.aggregator")
    a_logger.disabled = False
    a_logger.setLevel(logging.DEBUG)

    logger.setLevel(logging.DEBUG)

    pycronms = Pycronyms()
    pycronms.add_provider(Custom())
    pycronms.add_provider(Wikipedia())

    pycronms.fetch_all()

    os.makedirs(dir, exist_ok=True)
    logger.info(f"Created the directory {dir.absolute()} if needed")

    acronyms = sorted_recursive(pycronms.acronyms)

    try:
        write_acronyms(acronyms, dir)
        write_markdown_summary(acronyms, dir)
    except Exception as e:
        logger.exception(e)

        shutil.rmtree(dir, ignore_errors=True)
        logger.info(f"Removed the folder {dir.absolute()}")

        sys.exit(1)
